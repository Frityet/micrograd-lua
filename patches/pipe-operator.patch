diff --git a/test/share/lua/5.1/tl.tl b/lua_modules/share/lua/5.1/tl.tl
index d03d89a..be3485d 100644
--- a/test/share/lua/5.1/tl.tl
+++ b/lua_modules/share/lua/5.1/tl.tl
@@ -919,6 +919,7 @@ do
       "got >"
       "got /"
       "got :"
+      "got |"
       "got --["
       "string single"
       "string single got \\"
@@ -956,6 +957,7 @@ do
       ["got >"] = "op",
       ["got /"] = "op",
       ["got :"] = "op",
+      ["got |"] = "op",
       ["got --["] = nil, -- drop comment
       ["string single"] = "$ERR$",
       ["string single got \\"] = "$ERR$",
@@ -1015,6 +1017,7 @@ do
       ["="] = "got =",
       ["~"] = "got ~",
       ["["] = "got [",
+      ["|"] = "got |",
    }
 
    for c = string.byte("a"), string.byte("z") do
@@ -1062,7 +1065,7 @@ do
    for _, c in ipairs(single_char_kinds) do
       lex_any_char_kinds[c] = c
    end
-   for _, c in ipairs({"#", "+", "*", "|", "&", "%", "^"}) do
+   for _, c in ipairs({"#", "+", "*", "&", "%", "^"}) do
       lex_any_char_kinds[c] = "op"
    end
 
@@ -1529,6 +1532,16 @@ do
             end
             end_token("op", t)
             state = "any"
+         elseif state == "got |" then
+            local t: string
+            if c == ">" then
+               t = "|>"
+            else
+               t = "|"
+               fwd = false
+            end
+            end_token("op", t)
+            state = "any"
          elseif state == "string long" then
             if c == "]" then
                state = "string long got ]"
@@ -3172,6 +3185,7 @@ do
       [2] = {
          ["or"] = 1,
          ["and"] = 2,
+         ["|>"] = 3,
          ["is"] = 3,
          ["<"] = 3,
          [">"] = 3,
@@ -5921,8 +5935,70 @@ function tl.generate(ast: tl.Node, gen_target: GenTarget, opts?: GenerateOptions
          end,
       },
       ["op"] = {
+         before = function(_: nil, node: Node)
+            -- Transform |> by restructuring the AST
+            if node.op.op == "|>" and node.e2.kind == "op" and node.e2.op.op == "@funcall" then
+               -- Transform: lhs |> f(arg1, arg2, ...) into f(lhs, arg1, arg2, ...)
+               -- node.e1 is lhs
+               -- node.e2 is the @funcall node where:
+               --   node.e2.e1 is the function
+               --   node.e2.e2 is the expression_list of arguments
+               
+               -- Restructure: create new @funcall with lhs as first argument
+               local new_call = {
+                  f = node.f,
+                  y = node.y,
+                  x = node.x,
+                  kind = "op",
+                  op = node.e2.op, -- @funcall operator
+                  e1 = node.e2.e1, -- function
+                  e2 = {
+                     f = node.e2.e2.f,
+                     y = node.e2.e2.y,
+                     x = node.e2.e2.x,
+                     kind = "expression_list",
+                  }
+               }
+               
+               -- Insert lhs as first argument
+               table.insert(new_call.e2 as {Node}, 1, node.e1)
+               -- Copy remaining arguments
+               for i, arg in ipairs(node.e2.e2 as {Node}) do
+                  table.insert(new_call.e2 as {Node}, arg)
+               end
+               
+               -- Replace this node's structure with the new call
+               node.kind = new_call.kind
+               node.op = new_call.op
+               node.e1 = new_call.e1
+               node.e2 = new_call.e2
+            elseif node.op.op == "|>" then
+               -- Simple case: lhs |> f becomes f(lhs)
+               local new_call = {
+                  f = node.f,
+                  y = node.y,
+                  x = node.x,
+                  kind = "op",
+                  op = an_operator(node, 2, "@funcall"),
+                  e1 = node.e2, -- function
+                  e2 = {
+                     f = node.f,
+                     y = node.y,
+                     x = node.x,
+                     kind = "expression_list",
+                     [1] = node.e1,
+                  }
+               }
+               
+               node.kind = new_call.kind
+               node.op = new_call.op
+               node.e1 = new_call.e1
+               node.e2 = new_call.e2
+            end
+         end,
          after = function(_: nil, node: Node, children: {Output}): Output
             local out: Output = { y = node.y, h = 0 }
+            -- |> is transformed in before callback, so won't appear here
             if node.op.op == "@funcall" then
                add_child(out, children[1], "", indent)
                table.insert(out, "(")
@@ -13770,6 +13846,44 @@ do
       },
       ["op"] = {
          before = function(self: TypeChecker, node: Node)
+            -- Transform |> operator before type checking
+            if node.op.op == "|>" then
+               if node.e2.kind == "op" and node.e2.op.op == "@funcall" then
+                  -- Transform: lhs |> f(arg1, arg2, ...) into f(lhs, arg1, arg2, ...)
+                  local new_args = {
+                     f = node.e2.e2.f,
+                     y = node.e2.e2.y,
+                     x = node.e2.e2.x,
+                     kind = "expression_list",
+                  }
+                  
+                  -- Insert lhs as first argument
+                  table.insert(new_args as {Node}, 1, node.e1)
+                  -- Copy remaining arguments
+                  for _, arg in ipairs(node.e2.e2 as {Node}) do
+                     table.insert(new_args as {Node}, arg)
+                  end
+                  
+                  -- Replace node structure
+                  node.op = node.e2.op -- @funcall
+                  node.e1 = node.e2.e1 -- function
+                  node.e2 = new_args   -- new argument list
+               else
+                  -- Simple case: lhs |> f becomes f(lhs)
+                  local new_args = {
+                     f = node.f,
+                     y = node.y,
+                     x = node.x,
+                     kind = "expression_list",
+                     [1] = node.e1,
+                  }
+                  
+                  node.op = an_operator(node, 2, "@funcall")
+                  node.e1 = node.e2 -- function
+                  node.e2 = new_args
+               end
+            end
+            
             self:begin_scope()
             if node.expected then
                if node.op.op == "and" then
